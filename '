//use thiserror::Error;

use std::{borrow::BorrowMut, cell::RefCell, ops::DerefMut, rc::Rc};

use strum_macros::Display;
use thiserror::Error;

enum Chirality {
    R,
    S,
}

#[allow(unused)]
#[derive(Clone, Debug)]
struct Element {
    number: u8,
}

impl Element {
    fn new(number: u8) -> Self {
        Element { number }
    }
}

#[allow(unused)]
#[derive(Clone, Debug)]
struct Atom {
    element: Element,
    neutrons: u8,
    electrons: u8,   // same as protons
    oxi: Option<u8>, // oxidation state
}

impl Atom {
    fn new(element_num: u8) -> Self {
        let element = Element::new(element_num);
        Atom {
            electrons: element.number,
            element,
            neutrons: 0,
            oxi: None,
        }
    }
}

#[derive(Error, Clone, Debug, Display)]
enum ParsingError {
    MoleculeParsingError(String),
    CompoundParsingError(String),
}

#[allow(unused)]
#[derive(Clone, Debug)]
enum Particle {
    Atom(Atom),
    Molecule(Vec<Atom>),
}

impl Particle {
    fn new_atom(atom: Atom) -> Particle {
        Particle::Atom(atom)
    }

    fn new_molecule(atoms: Vec<Atom>) -> Result<Particle, ParsingError> {
        Ok(Particle::Molecule(atoms)).map_err(ParsingError::MoleculeParsingError)
    }
}

#[allow(unused)]
#[derive(Clone, Debug)]
struct Compound {
    // this is sort of like an iterator
    center: Atom,
    subst: Vec<Particle>,                    // substituents
    side_chains: Vec<RefCell<Rc<Compound>>>, // count of previous compounds
}

impl Compound {
    fn new(
        center: Atom,
        subst: Vec<Particle>,
        side_chains: Vec<RefCell<Rc<Compound>>>,
    ) -> Result<Compound, ParsingError> {
        Ok(Compound {
            center,
            subst,
            side_chains,
        })
        .map_err(ParsingError::CompoundParsingError)
    }

    fn as_box(
        center: Atom,
        subst: Vec<Particle>,
        side_chains: Vec<RefCell<Rc<Compound>>>,
    ) -> Result<Box<Compound>, ParsingError> {
        Ok(Box::new(Compound {
            center,
            subst,
            side_chains,
        }))
        .map_err(ParsingError::CompoundParsingError)
    }
    fn as_rc(
        center: Atom,
        subst: Vec<Particle>,
        side_chains: Vec<RefCell<Rc<Compound>>>,
    ) -> Result<Rc<RefCell<Compound>>, ParsingError> {
        Ok(Rc::new(RefCell::new(Compound {
            center,
            subst,
            side_chains,
        })))
        .map_err(ParsingError::CompoundParsingError)
    }
}

trait Parsable {}

fn main() {
    let mut cmp: Rc<RefCell<_>> =
        Compound::as_rc(Atom::new(3), vec![], vec![]).expect("Compound was expected");
    let mut compound = cmp.borrow_mut();
    compound.subst.push(Particle::new_atom(Atom::new(18)));
    cmp.borrow_mut().get_mut().subst.push(
        Particle::new_molecule(vec![Atom::new(7), Atom::new(7)]).expect("Molecule not parsed"),
    );
    let cmp2 = Compound::as_rc(Atom::new(3), vec![], vec![]).expect("Compound was expected");
    //     cmp.borrow_mut().side_chains.push(cmp2);
    //     cmp2.borrow_mut().side_chains.push(cmp);
    dbg!(cmp);
}
